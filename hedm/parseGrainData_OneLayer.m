function microstructure = parseGrainData_OneLayer(pname, qsym, varargin)
% USE parseGrainData_OneLayer_ff STARTING 2022-10
% parseGrainData_OneLayer
%   Parse the hedm grain file for one layer. currently works for FF-HEDM
%   data reducted using MIDAS only for now.
%
%   microstructure = parseGrainData_OneLayer(pname, qsym) reads the grain
%   log file and returns the microstructure information
%
%   INPUT:
%
%   pname
%       full file path of the grain log file generated by FF-HEDM MIDAS
%       code
%
%   qsym
%       Symmetry operators in quaternions
%
%   These arguments can be followed by a list of
%   parameter/value pairs. Options are:
%
%   'Technique'     far-field (F) or near-field (NF). default is FF.
%   'CrdSystem'     coordinate system in the log file (default is APS)
%	'LabToSample'	rigid body rotation to bring the sample frame coincide
%					with the laboratory frame. this option only works with
%					APS CrdSystem for now.
%	'C_xstal' 		single crystal stiffness matrix / tensor to compute the
%					stresses.
%	'OutputReflectionTable' outputs reflection table if requested. default is false.
%   'ComputeSelfMisoTable'  computes misorientation angle between the
%                           constituent grains. default is false.
%   'ComputeSelfDistTable'  computes COM distance table between the
%                           constituent grains. default is false.
%   'Verbose'               outputs more information on parser progress if
%                           true. default is false.
%
%   OUTPUT:
%   microstrcture with the following sub-fields
%       grains      = constituent grain information
%       nGrains     = number of grains found
%       miso_table  = self misorientation table (if requested)
%       dist_table  = self COM distance table (if requested)
%
%   nGrains
%       number of grains found in the volume
%
%   miso_table
%       misorientation table in between all the grains found
%
%   dist_table
%       distance table in between all the grains found
%
%   grains field has the following sub-fields
%       GrainID - grain id number designated by MIDAS
%       R - rotation matrix
%       quat - corresponding quaternion
%       rod - corresponding rodrigues vector
%       COM - center of mass position
%       lattprms - lattice parameter
%       DiffPos - positional discrepancy / uncertainty
%       DiffOme - omega discrepancy / uncertainty
%       DiffAngle - angular discrepancy / uncertainty
%       GrainRadius - grain radius
%       Completeness - completeness
%       StrainFab - strain in FABLE formulation
%       Strain - strain in strain gauge formulation
%       StrainFab_vec - vectorized StrainFab
%       Strain_vec - vectorized Strain
%       PhaseNumber - phase number
%       V - []
%       Esam - []
%       Ecry - []
%       F - []
%       ReflectionTable - reflection table with substructure
%       CrdSys - coordinate system
%       StrainFabUnits - StrainFab units *
%       StrainUnits - Strain units *
%       StressFab - stress computed from StrainFab *
%       Stress - stress computed from Strain *
%       StressFab_h - hydrostatic stress from StressFab *
%       StressFab_d - deviatoric stress from StressFab *
%       StressFab_vm - von Mises stress from StressFab *
%       Stress_h - hydrostatic stress from Stress *
%       Stress_d - deviatoric stress from Stress *
%       Stress_vm - von Mises stress from Stress *
%       StrainRMS - strain discrepancy / error from projection
%       C_xstal - single crystal stiffness *
%       * - only computed if requested
%
%   ReflectionTable has the following sub-fields
%       * all fields with Spots_csv prefix is from the SpotsMatrix.csv file
%       Spots_csv_SpotID = spot id designated by MIDAS after spot
%       consolidation
%       Spots_csv_ome = omega
%       Spots_csv_DetHCrd = detector H crd
%       Spots_csv_DetVCrd = detector V crd
%       Spots_csv_ome_raw = omega raw
%       Spots_csv_eta = eta
%       Spots_csv_RingNum = ring unmber
%       Spots_csv_YLab = Y crd of the spot in lab frame
%       Spots_csv_ZLab = Z crd of the spot in lab frame
%       Spots_csv_th = theta
%       Spots_csv_strain_error = strain error per spot
%       Spots_csv_derived_ome_Aero = omega angle in aero convention
%       Spots_csv_derived_tth = tth calculated from th
%       Spots_csv_derived_eta_vff = eta in vff convention
%       Spots_csv_derived_eta_hexrd = eta in HEXRD convention
%       * all fields with RingNr_csv prefix is from the Radius_StartNr_XXX.csv file
%       RingNr_csv_I_integrated = integrated intensity of the spot
%       RingNr_csv_ome = omega
%       RingNr_csv_YCen = Y position of the spot
%       RingNr_csv_ZCen = Z position of the spot
%       RingNr_csv_I_max = max intensity
%       RingNr_csv_ome_min = omega min where the spot was seen
%       RingNr_csv_ome_max = omega max where the spot was seen
%       RingNr_csv_RingRadius = ring radius in um
%       RingNr_csv_th = theta
%       RingNr_csv_eta = eta
%       RingNr_csv_dome = delta omega
%       RingNr_csv_nimg = number of images
%       RingNr_csv_grain_volume = grain volume
%       RingNr_csv_grain_radius = grain radius
%       RingNr_csv_I_pwdr = powder intensity
%       RingNr_csv_sig_r = spot width in radius
%       RingNr_csv_sig_eta = spot width in eta
%       RingNr_csv_derived_ome_Aero = omega in aero convention
%       RingNr_csv_derived_ome_min_Aero = min omega in aero convention
%       RingNr_csv_derived_ome_max_Aero = max omega in aero convention
%       RingNr_csv_derived_tth = 2theta
%       RingNr_csv_derived_eta_vff = vff eta computed from eta
%       RingNr_csv_derived_eta_hexrd = eta in HEXRD convention
%       * all fields with hkls_csv prefix is from the hkls.csv file
%       hkls_csv_hkls = family of crystallographic plane hkl
%       hkls_csv_dspacing = nominal dspacing
%       hkls_csv_qvec = scattering vector for the family of
%       crystallographic plane
%       hkls_csv_th = theta
%       hkls_csv_tth = 2tehta
%       hkls_csv_RingRadius = ring radius
%       num_spots = number of spots in the ReflectionTable
%
%   The columns of the Grains.csv file are:
%       Sp_ID O[0][0] O[0][1] O[0][2] O[1][0] O[1][1] O[1][2] O[2][0] O[2][1] O[2][2]
%       X Y Z a b c alpha beta gamma Err1 Err2 Err3 MeanRadius Confidence
%
%       where each row describes a grain
%
%       O[row][col] is the orientation matrix of the grain that takes crystal frame to
%       ESRF lab coordinate system.
%       X,Y,Z define the center of mass coordinate of the grain in ESRF
%       lab coordinate system
%       a, b, c, alpha, beta, gamma are the crystal lattice
%       parameters of the grain (NEED TO DESCRIBE HOW THESE ARE DEFINED)
%       Err1, Err2, Err3
%       MeanRadius is the size of the grain
%       Confidence is the completeness of the grain (number of g-vectors
%       found / number of g-vectors anticipated)
%
%   In the case of nf-HEDM, input file is from Ice9 file postprocessed with
%   segmentation routine. This functionality was originally provided by
%   Dave Menasche at Carnegie Mellon University.
%
%   The columns of the input file are:
%       grain id
%       Center of mass (x = along beam, y = OB, z = up)
%       Average Orientation in Bunge convention that transforms a vector
%       in crystal frame to the laboratory frame
%       Volume
%       AverageConfidence (bug in the segmentation routine)
%       NumberNeighbors
%       IDsofNeighbors
%       MisorsWithNeighbors
%
%   Example:
%       microstructure = parseGrainData_OneLayer(pname, qsym);
%
%   Outstanding issues:
%   a. Rmat - do we need transformation or not?
%
%   b. Additional needs for grain informatoin
%       SHOULD GET THESE AS WELL FROM MIDAS
%       nExpGvec = Number of expected G vectors
%       nMeasGvec = Number of measured G vectors
%       nMeasOnce = Number of G vectors measured once
%       nMeasMore = Number of G vectors measured more than once
%       meanIA = Average internal angle between prediced and measured
%       gvec = G vector table
%       hkl = 3 hkl values
return
% default options
optcell = {...
    'Technique', 'ff-midas', ...
    'NumFrames', 1440, ...
    'CrdSystem', 'APS', ...
    'LabToSample', 0, ...
    'C_xstal', nan, ...
    'OutputReflectionTable', false, ...
    'ComputeSelfMisoTable', false, ...
    'ComputeSelfDistTable', false, ...
    'Verbose', false, ...
    };

% update option
opts    = OptArgs(optcell, varargin);

disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
if strcmpi(opts.CrdSystem, 'APS')
    disp('COM / orientations / strains will be in the APS coordinate system.')
elseif strcmpi(opts.CrdSystem, 'ESRF')
    disp('COM / orientations / strains will be in the ESRF coordinate system')
else
    error('LAB coordinate system unknown')
end
disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')

if strcmpi(opts.CrdSystem, 'APS')
    R_ESRF2APS  = RMatOfQuat(QuatOfESRF2APS);
else
    R_ESRF2APS  = eye(3,3);
end

% disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
% if (opts.LabToSample == 0)
%     disp(sprintf('The LAB FRAME and SAMPLE FRAME are IDENTICAL WHEN OMEGA = %2.1f deg', opts.LabToSample))
% elseif (opts.LabToSample ~= 0)
%     disp(sprintf('The LAB FRAME and SAMPLE FRAME are IDENTICAL WHEN OMEGA = %2.1f deg', opts.LabToSample))
% end
% disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')

disp('converting LAB FRAME to the SAMPLE FRAME')
disp(sprintf('The LAB FRAME and SAMPLE FRAME are IDENTICAL WHEN OMEGA = %2.1f deg', opts.LabToSample))

RLab2Sam    = eye(3,3);
c   = cosd(opts.LabToSample);
s   = sind(opts.LabToSample);
switch lower(opts.CrdSystem)
    case 'aps'
        RLab2Sam    = [
            c 0 -s; ...
            0 1 0; ...
            s 0 c; ...
            ];
    case 'esrf'
        RLab2Sam    = [
            c s 0; ...
            -s c 0; ...
            0 0 1; ...
            ];
    otherwise
        error('LAB coordinate system unknown')
end
disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')

switch lower(opts.Technique)
    case 'ff-midas'
        
        
        pfname_hkls     = fullfile(pname, 'hkls.csv');
        pfname_grains   = fullfile(pname, 'Grains.csv');
        pfname_spots    = fullfile(pname, 'SpotMatrix.csv');
        pfname_idrings  = fullfile(pname, 'IDRings.csv');
        
        hkls_csv    = dlmread(pfname_hkls, ' ', 1, 0);
        Grains_csv  = load(pfname_grains);
        Spots_csv   = load(pfname_spots);
        IDRings_csv = dlmread(pfname_idrings, ' ', 1, 0);
        
        nFrames = opts.NumFrames;
        hkls    = unique(IDRings_csv(:,1));
        nGrains = size(Grains_csv, 1);
        
        for i = 1:1:length(hkls)
            fname                   = sprintf('Radius_StartNr_1_EndNr_%d_RingNr_%d.csv', nFrames, hkls(i));
            pfname                  = fullfile(pname, fname);
            RingNr_csv{hkls(i)}     = dlmread(pfname, ' ', 1, 0);
        end
        
        disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
        disp(sprintf('parsing ff-hedm grain data from %s', pfname_grains));
        disp(sprintf('number of grains in this layer : %d', nGrains));
        disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
        disp(sprintf('sorting ff-hedm spots data from %s', pfname_spots));
        disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
        
        nCols       = size(Grains_csv, 2);
        ct          = 1;
        
        disp(sprintf('total number of grains : %d', nGrains));
        grains(nGrains) = struct( ...
            'GrainID',[], ...
            'R',[], 'quat',[], 'rod',[], ...
            'COM',[], ...
            'lattprms',[], ...
            'DiffPos',[], 'DiffOme',[], 'DiffAngle',[], ...
            'GrainRadius',[], ...
            'Completeness',[], ...
            'StrainFab',[], 'Strain',[], ...
            'StrainFab_vec', [], 'Strain_vec', [], ...
            'PhaseNumber',[], ...
            'V',[],'Esam',[],'Ecry',[],'F',[], ...
            'ReflectionTable', [],  'CrdSys', []);
        
        % ROTATION FROM MIDAS IS [RMat]{c} = {l}
        % ROTATION TO GO FROM LAB TO SAMPLE IS [RLab2Sam]{l} = {s}
        % [RLab2Sam][RESRF2APS]{l} = {s}
        % [RLab2Sam][RESRF2APS][RMat]{c} = {s}
        for i = 1:1:nGrains
            
            %%% RAW RMAT OUTPUT FROM MIDAS
            % [RMat]{c} = {l}
            RMat    = reshape(Grains_csv(i, 2:10), 3, 3)';
            COM     = Grains_csv(i, 11:13);
            
            %%% TO TEST OUT RMAT RESHAPE & TRANSPOSE
            % Grains_csv(i, 2:10)
            % reshape(Grains_csv(i, 2:10), 3, 3)
            % pause
            
            % TRANSFORM RMAT SUCH THAT IT TAKES A VECTOR IN XSTAL FRAME TO THE SAMPLE FRAME. 
            RMat    = RLab2Sam*R_ESRF2APS*RMat;
            
            % TRANSFORM COM INTO THE SAMPLE FRAME
            COM     = RLab2Sam*R_ESRF2APS*COM';
            
            if strcmpi(opts.CrdSystem, 'APS')
                grains(ct).CrdSys	= 'APS';
            elseif strcmpi(opts.CrdSystem, 'ESRF')
                grains(ct).CrdSys	= 'ESRF';
            end
            Quat    = ToFundamentalRegionQ(QuatOfRMat(RMat), qsym);
            Rod     = RodOfQuat(Quat);
            
            grains(ct).GrainID = Grains_csv(i,1);
            grains(ct).R       = RMat;
            grains(ct).rod     = Rod;
            grains(ct).quat    = Quat;
            grains(ct).COM     = COM(:);
            
            grains(ct).lattprms     = Grains_csv(i, 14:19)';
            grains(ct).DiffPos      = Grains_csv(i, 20);
            grains(ct).DiffOme      = Grains_csv(i, 21);
            grains(ct).DiffAngle    = Grains_csv(i, 22);
            grains(ct).GrainRadius  = Grains_csv(i, 23);
            grains(ct).Completeness = Grains_csv(i, 24);
            
            % Grains_csv(i, 25:33)
            % reshape(Grains_csv(i, 25:33), 3, 3)
            % pause
            StrainFab   = reshape(Grains_csv(i, 25:33), 3, 3);
            Strain      = reshape(Grains_csv(i, 34:42), 3, 3);
            
            % STRAIN IS ALREADY IN THE ESRF LAB FRAME.
            % CONVERT TO APS FRAME IF NECESSARY.
            % CONVERT TO SAMPLE FRAME.
            % CONVERT MICRO-STRAIN TO STRAIN.
            grains(ct).StrainFab   = RLab2Sam*R_ESRF2APS*StrainFab*R_ESRF2APS'*RLab2Sam'./1000000;
            grains(ct).Strain      = RLab2Sam*R_ESRF2APS*Strain*R_ESRF2APS'*RLab2Sam'./1000000;
            
            grains(ct).StrainFabUnits  = 'strain';
            grains(ct).StrainUnits     = 'strain';
            
            StrainFab_vec       = VectorOfStressStrainMatrixInVM(grains(i).StrainFab);
            Strain_vec          = VectorOfStressStrainMatrixInVM(grains(i).Strain);
            
            grains(ct).StrainFab_vec   = StrainFab_vec;
            grains(ct).Strain_vec      = Strain_vec;
            
            if isnan(opts.C_xstal)
                grains(ct).StressFab    = nan(6,1);
                grains(ct).Stress       = nan(6,1);
                
                grains(ct).StressFab_h     = nan;
                grains(ct).StressFab_d     = nan(6,1);
                grains(ct).StressFab_vm    = nan;
                
                grains(ct).Stress_h    = nan;
                grains(ct).Stress_d    = nan(6,1);
                grains(ct).Stress_vm   = nan;
                
            elseif (size(opts.C_xstal,1) == 6) && (size(opts.C_xstal,2) == 6)
                %%% STRAIN IS ALREADY IN THE SAMPLE FRAME
                % [RMat] TAKES A VECTOR IN XSTAL FRAME TO THE SAMPLE FRAME
                % [RMat]{c}={s}
                % R   = RLab2Sam*R_ESRF2APS;
                T           = VectorizedCOBMatrix(RMat);
                C_sample    = T*opts.C_xstal*T';  % XSTAL STIFFNESS IN SAMPLE FRAME
                
                %%% FAB
                StressFab_vec               = C_sample*StrainFab_vec;
                grains(ct).StressFab   	    = StressFab_vec;
                grains(ct).StressFab_mtx    = MatrixOfStressStrainVectorInVM(StressFab_vec);
                grains(ct).StressFab_h      = VolumetricStressStrain(StressFab_vec);
                grains(ct).StressFab_d      = DeviatoricStressStrain(StressFab_vec);
                grains(ct).StressFab_vm     = VMStressStrain(StressFab_vec);
                
                %%% PK
                Stress_vec              = C_sample*Strain_vec;
                grains(ct).Stress       = Stress_vec;
                grains(ct).Stress_mtx   = MatrixOfStressStrainVectorInVM(Stress_vec);
                grains(ct).Stress_h     = VolumetricStressStrain(Stress_vec);
                grains(ct).Stress_d     = DeviatoricStressStrain(Stress_vec);
                grains(ct).Stress_vm    = VMStressStrain(Stress_vec);
            end
            grains(ct).StrainRMS   = Grains_csv(i, 43);
            grains(ct).C_xstal     = opts.C_xstal;
            
            %%% THIS IS FOR NEWER VERSION OF THE GRAINS OUTPUT
            if nCols > 43
                grains(ct).PhaseNumber  = Grains_csv(i, 44);
            end
            
            if opts.OutputReflectionTable
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %%% GENERATE REFLECTION TABLE
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                idx = grains(ct).GrainID == Spots_csv(:,1);
                
                RingNum = Spots_csv(idx,8);
                SpotID  = Spots_csv(idx,2);
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %%% SPOT TABLE
                ReflectionTable.Spots_csv_SpotID        = SpotID;
                ReflectionTable.Spots_csv_ome           = Spots_csv(idx,3);
                ReflectionTable.Spots_csv_DetHCrd       = Spots_csv(idx,4);
                ReflectionTable.Spots_csv_DetVCrd       = Spots_csv(idx,5);
                ReflectionTable.Spots_csv_ome_raw       = Spots_csv(idx,6);
                ReflectionTable.Spots_csv_eta           = Spots_csv(idx,7);
                ReflectionTable.Spots_csv_RingNum       = RingNum;
                ReflectionTable.Spots_csv_YLab          = Spots_csv(idx,9);
                ReflectionTable.Spots_csv_ZLab          = Spots_csv(idx,10);
                ReflectionTable.Spots_csv_th            = Spots_csv(idx,11);
                ReflectionTable.Spots_csv_strain_error  = Spots_csv(idx,12);
                
                %%% DERIVED VALUES
                ReflectionTable.Spots_csv_derived_ome_Aero  = -ReflectionTable.Spots_csv_ome;
                ReflectionTable.Spots_csv_derived_tth       = 2.*ReflectionTable.Spots_csv_th;
                ReflectionTable.Spots_csv_derived_eta_vff   = ReflectionTable.Spots_csv_eta;
                ReflectionTable.Spots_csv_derived_eta_hexrd = ConvertMIDASToHEXRD(ReflectionTable.Spots_csv_eta, ...
                    'ObjectToConvert', 'eta', 'Units', 'deg');
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %%% RING TABLE
                for j = 1:1:length(SpotID)
                    idx = (IDRings_csv(:,1) == RingNum(j)) & (IDRings_csv(:,3) == SpotID(j));
                    ringnum         = IDRings_csv(idx,1);
                    spotid_org(j)   = IDRings_csv(idx,2);
                    
                    if opts.Verbose
                        disp(sprintf('* grain %d spot %d is from ring number %d spot id %d', ...
                            grains(ct).GrainID, SpotID(j), ringnum, spotid_org(j)));
                    end
                    
                    idx = RingNr_csv{ringnum}(:,1) == spotid_org(j);
                    rt_I_integrated(j,1)    = RingNr_csv{ringnum}(idx,2);
                    rt_ome(j,1)             = RingNr_csv{ringnum}(idx,3);
                    rt_YCen(j,1)            = RingNr_csv{ringnum}(idx,4);
                    rt_ZCen(j,1)            = RingNr_csv{ringnum}(idx,5);
                    rt_I_max(j,1)           = RingNr_csv{ringnum}(idx,6);
                    rt_ome_min(j,1)         = RingNr_csv{ringnum}(idx,7);
                    rt_ome_max(j,1)         = RingNr_csv{ringnum}(idx,8);
                    rt_RingRadius(j,1)      = RingNr_csv{ringnum}(idx,9);
                    rt_th(j,1)              = RingNr_csv{ringnum}(idx,10);
                    rt_eta(j,1)             = RingNr_csv{ringnum}(idx,11);
                    rt_dome(j,1)            = RingNr_csv{ringnum}(idx,12);
                    rt_nimg(j,1)            = RingNr_csv{ringnum}(idx,13);
                    rt_grain_volume(j,1)    = RingNr_csv{ringnum}(idx,14);
                    rt_grain_radius(j,1)    = RingNr_csv{ringnum}(idx,15);
                    rt_I_pwdr(j,1)          = RingNr_csv{ringnum}(idx,16);
                    rt_sig_r(j,1)           = RingNr_csv{ringnum}(idx,17);
                    rt_sig_eta(j,1)         = RingNr_csv{ringnum}(idx,18);
                    
                    %%% HKLS TABLE
                    idx = find(hkls_csv(:,5) == ringnum);
                    idx = idx(1);
                    
                    ht_hkls(j,:)        = abs(hkls_csv(idx,1:3));
                    ht_dspacing(j,1)    = hkls_csv(idx,4);
                    ht_qvec(j,:)        = abs(hkls_csv(idx,6:8));
                    ht_th(j,1)          = hkls_csv(idx,9);
                    ht_tth(j,1)         = hkls_csv(idx,10);
                    ht_RingRadius(j,1)  = hkls_csv(idx,11);
                end
                
                ReflectionTable.RingNr_csv_I_integrated = rt_I_integrated;
                ReflectionTable.RingNr_csv_ome          = rt_ome;
                ReflectionTable.RingNr_csv_YCen         = rt_YCen;
                ReflectionTable.RingNr_csv_ZCen         = rt_ZCen;
                ReflectionTable.RingNr_csv_I_max        = rt_I_max;
                ReflectionTable.RingNr_csv_ome_min      = rt_ome_min;
                ReflectionTable.RingNr_csv_ome_max      = rt_ome_max;
                ReflectionTable.RingNr_csv_RingRadius   = rt_RingRadius;
                ReflectionTable.RingNr_csv_th           = rt_th;
                ReflectionTable.RingNr_csv_eta          = rt_eta;
                ReflectionTable.RingNr_csv_dome         = rt_dome;
                ReflectionTable.RingNr_csv_nimg         = rt_nimg;
                ReflectionTable.RingNr_csv_grain_volume = rt_grain_volume;
                ReflectionTable.RingNr_csv_grain_radius = rt_grain_radius;
                ReflectionTable.RingNr_csv_I_pwdr       = rt_I_pwdr;
                ReflectionTable.RingNr_csv_sig_r        = rt_sig_r;
                ReflectionTable.RingNr_csv_sig_eta      = rt_sig_eta;
                
                %%% DERIVED VALUES
                ReflectionTable.RingNr_csv_derived_ome_Aero     = -rt_ome;
                ReflectionTable.RingNr_csv_derived_ome_min_Aero = -rt_ome_max;
                ReflectionTable.RingNr_csv_derived_ome_max_Aero = -rt_ome_min;
                ReflectionTable.RingNr_csv_derived_tth          = 2.*rt_th;
                ReflectionTable.RingNr_csv_derived_eta_vff      = rt_eta;
                ReflectionTable.RingNr_csv_derived_eta_hexrd    = ConvertMIDASToHEXRD(ReflectionTable.RingNr_csv_eta, ...
                    'ObjectToConvert', 'eta', 'Units', 'deg');
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %%% HKL TABLE
                ReflectionTable.hkls_csv_hkls       = ht_hkls;
                ReflectionTable.hkls_csv_dspacing   = ht_dspacing;
                ReflectionTable.hkls_csv_qvec       = ht_qvec;
                ReflectionTable.hkls_csv_th         = ht_th;
                ReflectionTable.hkls_csv_tth        = ht_tth;
                ReflectionTable.hkls_csv_RingRadius = ht_RingRadius;
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                ReflectionTable.num_spots           = length(ReflectionTable.Spots_csv_SpotID);
                
                grains(ct).ReflectionTable = ReflectionTable;
            end
            ct  = ct + 1;
        end
        
        if opts.ComputeSelfMisoTable
            disp('************************************************')
            disp('misorientation table was requested')
            disp('this operation can take some time depending on the number of grains')
            disp('************************************************')
            miso_table  = zeros(nGrains,nGrains);
            for i = 1:1:nGrains-1
                idx = i+1;
                q1  = grains(i).quat;
                q2  = [grains(idx:end).quat];
                miso_table(i,idx:end)  = Misorientation(q1, q2, qsym);
            end
            microstructure.miso_table   = miso_table;
        end
        if opts.ComputeSelfDistTable
            disp('************************************************')
            disp('COM distance table was requested')
            disp('this operation can take some time depending on the number of grains')
            disp('************************************************')
            dist_table  = zeros(nGrains,nGrains);
            for i = 1:1:nGrains-1
                idx = i+1;
                q1  = grains(i).COM;
                q2  = [grains(idx:end).COM];
                dq  = q2 - q1;
                dq  = sqrt(sum(dq.*dq,1));
                dist_table(i,idx:end)  = dq;
            end
            microstructure.dist_table   = dist_table;
        end
        
        microstructure.grains       = grains;
        microstructure.nGrains      = nGrains;
        
        %     COM = [Grains(:).COM]';
        %     vm  = [Grains(:).StressFab_vm]';
        %     pfname  = 'test.csv';
        %     fid = fopen(pfname, 'w');
        %     fprintf(fid, 'x,y,z,vm\n');
        %     fclose(fid);
        %     dlmwrite('test.csv', [COM vm], 'delimiter', ',', '-append')
    case 'nf-midas'
        disp(sprintf('parsing nf-hedm data from %s', pfname));
        
        fid = fopen(pfname);
        tline = fgetl(fid);
        counter = 1;
        
        while ischar(tline)
            Grains_csv	= sscanf( tline , '%f', 10)';
            
            COM	= Grains_csv(2:4);
            %%% THIS IS Bunge Angles GOING FROM LAB TO CRYSTAL
            BungeAngles = Grains_csv(5:7)';
            %%% CONVERTS BUNGE ANGLES TO ROT MATRIX THEN TRANSPOSE TO CHANGE
            %%% ITS MEANING TO "CRYSATL TO LAB"
            RMat    = RMatOfBunge(BungeAngles, 'degrees')';
            
            RMat    = R_ESRF2APS*RMat;
            COM     = R_ESRF2APS*COM';
            Quat    = ToFundamentalRegionQ(QuatOfRMat(RMat), qsym);
            
            if strcmpi(opts.CrdSystem, 'APS')
                grains(counter).CrdSys	= 'APS';
            elseif strcmpi(opts.CrdSystem, 'ESRF')
                grains(counter).CrdSys	= 'ESRF';
            end
            
            grains(counter).BungeAngles    = BungeAngles;
            grains(counter).RMat           = RMat;
            grains(counter).Quat           = Quat;
            grains(counter).COM            = COM(:);
            
            grains(counter).Volume       = Grains_csv(8);
            grains(counter).Confidence   = Grains_csv(9);
            
            grains(counter).NumNeighbors	= Grains_csv(10);
            
            B   = sscanf(tline,'%f',10+2*Grains_csv(10));
            grains(counter).IDofNeighbors      = B(11:11+Grains_csv(10)-1);
            grains(counter).MisWithNeighbors   = B(11+Grains_csv(10):end);
            tline = fgetl(fid);
            counter = counter+1;
        end
        fclose(fid);
    otherwise
        error('Technique unknown.')
end
